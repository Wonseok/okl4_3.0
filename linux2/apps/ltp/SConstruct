import SCons.Errors
import os.path
import glob
Import("*") 

# we want to avoid nptl as much as possible on ia32
# the system calls can't be implemented without changes
# to the ia32 pistachio port
if env.machine.arch == "ia32":
    env['ENV']['LD_ASSUME_KERNEL']='2.4.10'

print "env['CCFLAGS'] %s" % env['CCFLAGS']

print "args[\"tests\"] is " , args["tests"]

inst = args["install_dir"]

lib = env.StaticLibrary("ltp", src_glob("lib/*.c"), CPPPATH="include")[0]
lib2 = env.StaticLibrary("testsuite", src_glob("testcases/kernel/syscalls/lib/*.c"), CPPPATH="include")[0]
libipc = env.StaticLibrary("ipc", src_glob("testcases/kernel/syscalls/ipc/lib/*.c"), CPPPATH="include")[0]
#libmm = env.StaticLibrary("mm", src_glob("testcases/kernel/mem/libmm/*.c"), CPPPATH="include")[0]

tests = []

##
## LTP: kernel/syscalls test suite
##

paths = src_glob("testcases/kernel/syscalls/*")
paths += src_glob("testcases/kernel/syscalls/ipc/*")
excepts = ["Makefile", "lib", "libevent", "ipc", "nftw"] + [ "epoll"]
paths = [path for path in paths if
         os.path.basename(path) not in excepts]



for path in paths:
    tests += src_glob("%s/*.c" % path)

bns = []
uniq_tests = []
# include each test only once
for test in tests:
    if os.path.basename(test) not in bns:
	uniq_tests.append(test)
	bns.append(os.path.basename(test))
    
files = []
ltpdir = "%s/ltp" % inst
bindir = "%s/testcases/bin" % ltpdir
pandir = "%s/pan" % ltpdir
rundir = "%s/runtest" % ltpdir

for test in uniq_tests:
    CPPDEFINES = []
    # Ensure things work on ia32 which does not yet support native posix
    # threads library on wombat
    #
    # we only want to link against libpthread 
    # in sigaction01 test
    if env.machine.arch != "ia32":
    	LIBS = ["ltp", "testsuite", "pthread", "ipc"]
    else:
        LIBS = ["ltp", "testsuite",  "ipc"]
        if "sigaction01" in test:
            LIBS.append("pthread")

    #defines for specific tests
    if "fcntl" in test:
        CPPDEFINES = ["_GNU_SOURCE"]
    #both signaction tests define GLIBC_SICACTION_BUG=1
    if "sigaction" in test:
        CPPDEFINES = ["GLIBC_SIGACTION_BUG=1"]

    if "sigaction02" in test:
        CPPDEFINES = ["_GNU_SOURCE"]
    if "sigpending" in test:
        CPPDEFINES = ["_GNU_SOURCE"]

    if "setrlimit03" in test:
        continue

    prog =                      env.Program(test,
                                 CPPPATH=["include", "testcases/kernel/syscalls/ipc/lib", "testcases/kernel/include"],
                                 LIBS = LIBS,
                                 CPPDEFINES = CPPDEFINES,
                                 LIBPATH=[os.path.dirname(lib.abspath),
                                          os.path.dirname(lib2.abspath),
                                          os.path.dirname(libipc.abspath)])
    env.AddPostAction(prog, "%s $TARGET" % env.toolchain.dict["STRIP"])
    files += Install(bindir,prog)
files += Install(bindir, 'testcases/kernel/syscalls/mount/setuid_test.mode.sh')

src_nftw = []
src_nftw.append(("nftw01", ["testcases/kernel/syscalls/nftw/" + fn for fn in ["nftw.c", "tools.c", "test_func.c", "test.c", "lib.c"]]))
src_nftw.append(("nftw6401", ["testcases/kernel/syscalls/nftw/" + fn for fn in ["nftw64.c", "tools64.c", "test_func64.c", "test64.c", "lib64.c"]]))

for name, src in src_nftw:
    prog =  env.Program(name, src,
	                                 CPPPATH=["include"],
                                 LIBS=["ltp"],
                                 CCFLAGS = ["-ansi", "-O", "-g", "-Wall"],
                                 CPPDEFINES = ["LINUX", "_XOPEN_SOURCE_EXTENDED",
                                               "_XOPEN_SOURCE", "_LARGEFILE_SOURCE",
                                               "_LARGEFILE64_SOURCE"],
                                 LIBPATH=[os.path.dirname(lib.abspath),
                                          os.path.dirname(lib2.abspath),
                                          os.path.dirname(libipc.abspath)])
    AddPostAction(prog, "%s $TARGET" % env.toolchain.dict["STRIP"])
    files += Install(bindir, prog)

for file_name in ['testcases/kernel/syscalls/syslog/syslog%02d' % x for x in range(1, 11)]:
    files += Install(bindir, file_name)

##
## LTP: kernel/mm test suite
##

tests = []
for dir in [x for x in src_glob('testcases/kernel/mem/*') if x[21:] not in ['hugetlb', 'libmm', 'Makefile']]:
    tests += src_glob(dir +'/*.c')

for test in tests:

    if env.machine.arch == "ia32":
    	LIBS=['ltp']
        if "mtest05" in test or "mtest06" in test or "mtest07" in test:
            LIBS.append("pthread")


    else:
        LIBS=['ltp', 'pthread']

    prog = env.Program(test, 
		       CPPPATH=['include'], LIBS=LIBS, 
		       LIBPATH=[os.path.dirname(x.abspath) for x in [lib]])
    files += Install(bindir, prog)


##
## LTP: kernel/ipc test suite
##

tests = []
for dir in [x for x in src_glob('testcases/kernel/ipc/*') if x[21:] not in ['ipc_stress', 'Makefile']]:
    tests += src_glob(dir +'/*.c')
for test in tests:

    if env.machine.arch == "ia32":
    	LIBS=['ltp']
	if "sem02" in test:
	    LIBS.append("pthread")
    else:
        LIBS=['ltp', 'pthread']
    prog = env.Program(test, 
		       CPPPATH=['include'], LIBS=LIBS, 
		       LIBPATH=[os.path.dirname(x.abspath) for x in [lib]])

    env.AddPostAction(prog, "%s $TARGET" % env.toolchain.dict["STRIP"])
    files += Install(bindir, prog)


##
## LTP: kernel/timers test suite
##

tests = []
for dir in [x for x in src_glob('testcases/kernel/timers/*') if x[24:] not in ['Makefile']]:
    tests += src_glob(dir +'/*.c')
for test in tests:
    if env.machine.arch == "ia32":
    	LIBS=['ltp']
    else:
        LIBS=['ltp', 'pthread']


    prog = env.Program(test, 
		       CPPPATH=['include', 'testcases/kernel/include', 'testcases/kernel/timers/include'], LIBS=LIBS, 
		       LIBPATH=[os.path.dirname(x.abspath) for x in [lib]])
    files += Install(bindir, prog)


##
## LTP: crashme test suite
##

for name in ['testcases/misc/crash/crash01.c', 'testcases/misc/crash/crash02.c', 'testcases/kernel/fs/proc/proc01.c']:
    prog = env.Program(name,
		       CPPPATH=['include'], LIBS=['ltp'], 
		       LIBPATH=[os.path.dirname(x.abspath) for x in [lib]])
    files += Install(bindir, prog)
    

##
## LTP: API commands
##

prog = env.Program('tools/apicmds/ltpapicmd.c',
		   CPPPATH=['include'], LIBS=['ltp'], 
		   LIBPATH=[os.path.dirname(x.abspath) for x in [lib]])
files += Install(bindir, prog)
for dest in ['tst_brk', 'tst_brkm', 'tst_res', 'tst_resm', 'tst_exit', 'tst_flush', 'tst_brkloop', 'tst_brkloopm']:
    files += InstallAs(os.path.join(bindir, dest), prog)


#Take all starting with a-n
print args["tests"]
def first(each):
    return str(each).split(os.sep)[-1][0]
if args["tests"] == "set1":
    files = [each for each in files if first(each) < "g"]
elif args["tests"] == "set2":
    files = [each for each in files if first(each) >= "g" and first(each) < "s"]
elif args["tests"] == "set3":
    files = [each for each in files if first(each) >= "s"]
elif args["tests"] != "all":
    raise SCons.Errors.UserError, "ltp must be one of set1, set2, set3 or all"

src_pan = []
src_pan.append(("pan2", ["pan/" + fn for fn in ["pan.c", "zoolib.c", "splitstr.c"]]))

for name, src in src_pan:
    if name == "pan2":
        files += InstallAs(pandir + "/pan",
                         env.Program(name, src,
                                     CPPPATH=["include"]
                                     )
                         )
    else:
        files += Install(pandir,
                         env.Program(name, src,
                                     CPPPATH=["include"]
                                     )
                         )

files += Install(ltpdir, "runltp")
files += Install(ltpdir, "runltplite.sh")
files += Install(ltpdir, "IDcheck.sh")
files += Install(ltpdir, "ver_linux")
#files += Install(ltpdir, "runltplite.sh")
#files += Install(bindir, "ltp_syscall_test")
#files += Install(bindir, "ltp_should_pass")

files += Install(rundir, src_glob("runtest/*"))

Return("files")
